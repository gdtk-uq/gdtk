#! /usr/bin/env python3
"""
build-uniform-lut.py

Build look-up-table for the behaviour of a single-temperature gas.
We just collate the results in a look-up-table.

Authors: PJ and RJG
Versions:
    06-April-2012: Fresh start, building on cea2_gas module.
    16-Jan-2020: Port to DGD project.
"""

import sys, numpy, math, time
from gdtk.gas import GasModel, GasState

#-----------------------------------------------------------------------------

def get_u_offset(gs, T):
    """
    At a suitably-low value of temperature, compute the energy offset for the gas.

    mygas: a GasState object
    T: temperature at which to evaluate the offset
    Returns: offset value to be added to gas internal energy.

    It is convenient to have the reference temperature of 0 degrees K
    for internal energy and enthalpy, so that u = C_v * T, approximately.
    This is quite different to the reference temperature of 298 degrees K
    used by CEA, for example, so we'll compute an offset value and
    shift the original value of internal energy by this offset in future.
    """
    gs.p = 100.0e3
    gs.T = T
    gs.update_thermo_from_pT()
    return gs.Cv * T - gs.internal_energy

def get_u_range(gs, T_min, T_max, log_rho_values):
    """
    Scan the boundary of the temperature and density to determine
    the range of internal that can be comfortably computed
    by the original gas model.
    """
    u_values = []
    for log_rho in log_rho_values:
        gs.rho = math.pow(10.0,log_rho); gs.T = T_min
        gs.update_thermo_from_rhoT()
        u_values.append(gs.internal_energy)
    u_min = max(u_values)
    u_values = []
    for log_rho in log_rho_values:
        gs.rho = math.pow(10.0,log_rho); gs.T = T_max
        gs.update_thermo_from_rhoT()
        u_values.append(gs.internal_energy)
    u_max = min(u_values)
    return u_min, u_max

def build_table(gs, tableName, T_min=200.0, T_max=20000.0,
                log_rho_min=-6.0, log_rho_max=2.0, T_for_offset=302.0):
    """
    Compute gas thermo properties for a mesh of internal-energy and density values
    and write an encoded form of the thermo data to a Lua-format file.

    gs: a GasState object
    gasName: string name of the gas, used to construct the table file name.
    T_min: in degrees K
    T_max: in degrees K
    log_rho_min: log-base-10 of minimum density in kg/m**3
    log_rho_max: log-base-10 of maximum density in kg/m**3
    T_for_offset: Temperature at which to determine energy offset.
        Mostly, any low temperature will suffice, however co2 needs T=600.

    The file produced is intended for later use by the uniform-LUT gas model.
    """
    # Keep density range on a logarithmic scale.
    irsteps = 50
    dlr = (log_rho_max - log_rho_min) / irsteps
    log_rho_values = numpy.linspace(log_rho_min, log_rho_max, irsteps+1)
    #
    # Internal energy range on a linear scale.
    print("T_for_offset=", T_for_offset)
    u_offset = get_u_offset(gs, T_for_offset)
    print("u_offset=", u_offset)
    u_min, u_max = get_u_range(gs, T_min, T_max, log_rho_values)
    print("u_min=", u_min, "u_max=", u_max)
    iusteps = 400
    du = (u_max - u_min) / iusteps
    u_values = numpy.linspace(u_min, u_max, iusteps+1)
    #
    # Set up a reference condition for the entropy data.
    # We pick a point that will not be coincident with any of
    # the tabulated points to (hopefully) avoid dividing by zero
    # when encoding entropy as Cp_hat later on.
    rho = math.pow(10.0, log_rho_max)
    gs.rho = rho; gs.u = u_min+0.5*du
    gs.update_thermo_from_rhou()
    gs.update_trans_coeffs()
    T1 = gs.T; p1 = gs.p; s1 = gs.entropy

    fname = 'lut-' + tableName + '.lua'
    print("Writing out look-up table: %s" % fname)
    fp = open(fname, 'w')
    fp.write("-- Auto-generated by build-uniform-lut.py on: %s\n" % time.asctime())
    fp.write("model = 'look-up table'\n")
    fp.write("with_entropy = 1\n")
    fp.write("p1 = %g\n" % p1)
    fp.write("T1 = %g\n" % T1)
    fp.write("s1 = %g\n" % s1)
    fp.write("iesteps = %d\n" % iusteps) # retain old name in table
    fp.write("irsteps = %d\n" % irsteps)
    # It is nice to have e = Cv * T in the table.
    fp.write("emin = %g\n" % (u_min+u_offset))
    fp.write("de = %g\n" % du)
    fp.write("lrmin = %g\n" % log_rho_min)
    fp.write("dlr = %g\n" % dlr)
    # Now, write the table data.
    fp.write("data = {\n")
    for u in u_values:
        print('*', end=' ')
        sys.stdout.flush()
        fp.write("{\n")
        for log_rho in log_rho_values:
            rho = math.pow(10.0, log_rho)
            gs.rho = rho; gs.u = u
            gs.update_thermo_from_rhou()
            gs.update_trans_coeffs()
            Cv_hat = (u + u_offset) / gs.T
            R_hat = gs.p / (rho * gs.T)
            gamma_hat = gs.a * gs.a / (R_hat * gs.T)
            Cp_hat = (gs.entropy - s1 + R_hat*math.log(gs.p/p1))/(math.log(gs.T/T1))
            fp.write("{%g, %g, %g, %g, %g, %g, %g},\n" %
                     (Cv_hat, gs.Cv, R_hat, Cp_hat, gamma_hat, gs.mu, gs.k))
        fp.write("},\n")
    fp.write("}\n\n")
    fp.close()
    print()
    return

#-----------------------------------------------------------------------------

if __name__ == '__main__':
    print("Begin build-uniform-lut.py...")
    from optparse import OptionParser, OptionGroup
    usage = "Usage: %prog [options]"
    parser = OptionParser(usage=usage)
    parser.add_option("-g", "--gas-model", action="store", type="string", dest="gasModelFile",
                      help="file name of the input gas-model")
    parser.add_option("-n", "--table-name", action="store", type="string", dest="tableName",
                      help="file name for the generated look-up table")
    parser.add_option("-b", "--bounds", action="store", type="string", dest="bounds",
                      default="200.0,20000.0,-6.0,2.0",
                      help="bounds of the table in form \"T_min,T_max,log_rho_min,log_rho_max\"")
    parser.add_option("-T", "--T-for-offset", action="store", type="string", dest="T_for_offset",
                      default="302.0",
                      help="Temperature (degree K) at which to evaluate the internal energy offset.")
    (options, args) = parser.parse_args()
    if options.tableName == None or options.gasModelFile == None:
        parser.print_help()
        print("")
        print("Example 1: build-uniform-lut --gas-model=cea-air5species-gas-model.lua"+
              " --table-name=air5species")
        print("Example 2: build-uniform-lut --gas-model=cea-air13species-gas-model.lua"+
              " --table-name=air13species --T-for-offset=600.0 --bounds=\"600,20000,-6.0,2.0\"")
        print("Example 3: build-uniform-lut --gas-model=cea-co2-gas-model.lua"+
              " --table-name=co2 --T-for-offset=650.0 --bounds=\"1000.0,20000,-6.0,2.0\"")
        print("Example 4: build-uniform-lut --gas-model=cea-co2-ions-gas-model.lua"+
              " --table-name=co2-ions --T-for-offset=1000.0 --bounds=\"1000.0,20000,-6.0,2.0\"")
        print("")
        print("Sometimes CEA2 has problems and the table will fail to build.")
        print("The best approach to fixing the problem seems to be to raise")
        print("the lower temperature boundary if the table,")
        print("as shown in examples 2, 3 and 4 (above).")
        sys.exit()
    T_min, T_max, log_rho_min, log_rho_max = [float(item) for item in options.bounds.split(',')]
    T_for_offset = float(options.T_for_offset)
    print("Density, Temperature ranges:")
    print("    log_rho_min=", log_rho_min, "log_rho_max=", log_rho_max)
    print("    T_min=", T_min, "T_max=", T_max)
    print("Building table for gas model:", options.gasModelFile)
    gmodel = GasModel(options.gasModelFile)
    assert gmodel.n_modes == 0, "Use only a single-temperature gas model."
    gs = GasState(gmodel)
    build_table(gs, options.tableName, T_min, T_max, log_rho_min, log_rho_max, T_for_offset)
    print("Done.")
