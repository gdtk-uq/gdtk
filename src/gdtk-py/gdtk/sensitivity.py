#!/usr/bin/env python
""" sensitivity.py

This script calculates the sensitivity and uncertainty in each
output property due to the various input parameters using a set
of calculations generated by "perturb.py".

The calculation method follows that outlined in the text book:
    Coleman, HW and Steele, WG (1999). Experimentation and
    Uncertainty Analysis for Engineers. 2nd edition. New York,
    John Wiley & Sons, Inc. DOI: 10.2514/2.3773 

Note that this script DOES NOT account for correlated uncertainties;
that is, it assumes the input variable uncertainties are completely 
independent of one another. 

The user must supply a function called "read_outfile.py" which reads
the outfile of the users analysis code and returns a dictionary of 
results and list of output variables (to be analysed).
 
.. Author: Luke Doherty (luke.doherty@eng.ox.ac.uk)
           Oxford Thermofluids Institute
           The University of Oxford
"""

VERSION_STRING = "05-May-2020"

import shlex, string
import sys, os, copy
E3BIN = os.path.expandvars("$HOME/e3bin")
sys.path.append(E3BIN) # installation directory
sys.path.append("") # so that we can find user's scripts in current directory
import optparse
import numpy as np #import array
np.seterr(divide='ignore',invalid='ignore')
from perturb_utils import read_case_summary
from sensitivity_input_utils import sensitivity_input_checker
from sensitivity_utils import get_values, write_sensitivity_summary,\
                              write_uncertainty_summary
from read_outfile import read_outfile

#from nenzfr_utils import run_command, quote, read_case_summary, \
#     read_nenzfr_outfile, read_estcj_outfile
#from nenzfr_input_utils import input_checker, nenzfr_perturbed_input_checker, nenzfr_sensitivity_input_checker

#---------------------------------------------------------------
def run_sensitivity(cfg):
    """
    Function that accepts a config dictionary and runs a 
    sensitivity analysis
    """
    #
    cfg['bad_input'] = False
    #
    # First check our input
    cfg = sensitivity_input_checker(cfg)
    # bail out here if there is an issue
    if cfg['bad_input']:
        return -2
    
    # Read the sensitivity_case_summary file to get the perturbed
    # variables and their various values
    perturbedVariables, dictOfCases = read_case_summary()
    #dontNeed, dictOfCases = read_case_summary()
    #perturbedVariables = copy.deepcopy(cfg['inputVariables'])
    
    #print perturbedVariables
    #print dictOfCases
    #print
    #print cfg
    
    # Make a copy of list of variables we want to analyse
    exitVar = copy.deepcopy(cfg['outputVariables'])

    # Define the name of the nominal case and load the exit plane data
    nominal = 'case000'
    nominalData, allExitVar = \
                        read_outfile('./'+nominal+'/'+cfg['resultsFile']) 
    
    #nominalData, exitVar = read_nenzfr_outfile('./'+nominal+'/'+\
    #                                           cfg['jobName']+'-exit.stats')
    # Load the nozzle supply data
    #nominalSupply = read_estcj_outfile('./'+nominal+'/'+cfg['jobName']+'-estcj.dat')
    # Now add the relevant supply data (T, h) to the nominalData dictionary
    #nominalData['supply_rho'] = nominalSupply['rho']
    #nominalData['supply_T'] = nominalSupply['T']
    #nominalData['supply_h'] = nominalSupply['h']
    # Add the supply variables to the exitVar list
    #exitVar.insert(0,'supply_rho')
    #exitVar.insert(1,'supply_T')
    #exitVar.insert(2,'supply_h')
    # Add extra variables of interest (q, Re_u, m_dot)
    #nominalData, exitVar = add_extra_variables(nominalData, exitVar)
     
    #nominalValues = get_values(nominalData, exitVar)
    #print 'nominalValues: ',nominalValues
    
     
    # Extract the input uncertainties for easier use. We must use the
    # relative values
    inputUncertainties = copy.deepcopy(cfg['inputVariablesUncertainty_rel'])
    
    
    # Loop through each of the perturbed variables
    sensitivity_rel = {}
    #sensitivity_rel2 = {}
    sensitivity_abs = {}
    #sensitivity_abs2 = {}
    uncertainty = {}
    #uncertainty2 = {}

    for k in range(len(perturbedVariables)):
        var = perturbedVariables[k]
        print var
        #if var == 'CoreRadiusFraction':
        #    perturb_CoreRadiusFraction(var, perturbedVariables,\
        #                               dictOfCases, cfg['levels'])
        
        # Define the name of the relevant perturbed cases and load the
        # associated data
        high = 'case'+"{0:02}".format(k)+'1'
        highData, dontNeed = read_outfile('./'+high+'/'+cfg['resultsFile'])
        
        #highData, dontNeed  = read_nenzfr_outfile('./'+high+'/'+\
        #                                          cfg['jobName']+'-exit.stats')
        #highSupply = read_estcj_outfile('./'+high+'/'+cfg['jobName']+'-estcj.dat')
        #highData['supply_rho'] = highSupply['rho']
        #highData['supply_T'] = highSupply['T']
        #highData['supply_h'] = highSupply['h']
        #highData, dontNeed = add_extra_variables(highData, [])

        low = 'case'+"{0:02}".format(k)+'2'
        lowData, dontNeed = read_outfile('./'+low+'/'+cfg['resultsFile'])
        
        #lowData, dontNeed = read_nenzfr_outfile('./'+low+'/'+\
        #                                        cfg['jobName']+'-exit.stats')
        #lowSupply = read_estcj_outfile('./'+low+'/'+cfg['jobName']+'-estcj.dat')
        #lowData['supply_rho'] = lowSupply['rho']
        #lowData['supply_T'] = lowSupply['T']
        #lowData['supply_h'] = lowSupply['h']
        #lowData, dontNeed = add_extra_variables(lowData, [])

        print low, nominal, high
        
        # Values of the freestream properties at the perturbed conditions
        #highValues = get_values(highData,exitVar)
        #lowValues = get_values(lowData,exitVar)
        #print 'highValues: ',highValues
        #print 'lowValues: ',lowValues
        #print 'highData: ',highData
        #print 'lowData: ',lowData
        #print 'nominalData: ',nominalData
        #print dictOfCases[high]
        #print perturbedVariables
        #print perturbedVariables.index(var)
        #print dictOfCases[high][var]
        
        # Values of the perturbed input values
        highX = dictOfCases[high][var]
        lowX = dictOfCases[low][var]
        nominalX = dictOfCases[nominal][var]
        #print 'highX: ',highX
        #print 'lowX: ',lowX
        #print 'nominalX: ',nominalX
        
        if cfg['levels'] == 3:
            # As the perturbations may not be centered on the nominal
            # condition we caculate the gradient by taking a weighted
            # average of the forward and backward derivatives. The
            # weightings are such that the truncation error associated
            # with this gradient estimate is O(3) or higher (i.e. the
            # weightings are such that the second order terms in the Taylor
            # series expansion cancel. Thanks to D.Petty for this theory.)
            highWeighting = (nominalX - lowX)/(highX - lowX)
            lowWeighting = (highX - nominalX)/(highX - lowX)
            
            # Calculate the aboslute sensitivities
            #sensitivity_abs[var] = ( highWeighting*(np.array(highValues)-\
            #                                    np.array(nominalValues))/\
            #                                   (highX - nominalX) + \
            #                     lowWeighting*(np.array(nominalValues)-\
            #                                   np.array(lowValues))/\
            #                                  (nominalX - lowX)     )
            sensitivity_abs[var] = {k: ( highWeighting*(highData[k]-\
                                                nominalData[k]) /\
                                               (highX - nominalX) + \
                                          lowWeighting*(nominalData[k]-\
                                                lowData[k]) /\
                                               (nominalX - lowX) ) \
                                    for k in exitVar}
            #print
            #print 'exitVar: ',exitVar
            #print
            #print 'sens_abs[var]: ',sensitivity_abs[var]
            
            # Calculate the relative sensitivities
            #sensitivity_rel[var] = sensitivity_abs[var]*\
            #                       nominalX/np.array(nominalValues)
            sensitivity_rel[var] = {k: sensitivity_abs[var][k]*\
                                        nominalX/nominalData[k] \
                                     for k in exitVar}
            
            #print 'sens_rel[var]: ',sensitivity_rel[var]
            
        elif cfg['levels'] == 5:
            # For 5 levels per variable we have additional cases
            # that need to be loaded. Again we do not assume that
            # the levels are equally spaced around the nominal.
            # The weightings are such that the truncation error
            # associated with this estimate is O(4) or higher.
            tooHigh = 'case'+"{0:02}".format(k)+'3'
            tooHighData, dontNeed = \
                   read_outfile('./'+tooHigh+'/'+cfg['resultsFile']) 
            #tooHighData,dontNeed = \
            #      read_nenzfr_outfile('./'+tooHigh+'/'+cfg['jobName']+'-exit.stats')
            #tooHighSupply = read_estcj_outfile('./'+tooHigh+'/'+cfg['jobName']+'-estcj.dat')
            #tooHighData['supply_rho'] = tooHighSupply['rho']
            #tooHighData['supply_T'] = tooHighSupply['T']
            #tooHighData['supply_h'] = tooHighSupply['h']
            #tooHighData, dontNeed = add_extra_variables(tooHighData, [])

            tooLow = 'case'+"{0:02}".format(k)+'4'
            tooLowData, dontNeed = \
                  read_outfile('./'+tooLow+'/'+cfg['resultsFile'])
            
            #tooLowData,dontNeed = \
            #      read_nenzfr_outfile('./'+tooLow+'/'+cfg['jobName']+'-exit.stats')
            #tooLowSupply = read_estcj_outfile('./'+tooLow+'/'+cfg['jobName']+'-estcj.dat')
            #tooLowData['supply_rho'] = tooLowSupply['rho']
            #tooLowData['supply_T'] = tooLowSupply['T']
            #tooLowData['supply_h'] = tooLowSupply['h']
            #tooLowData, dontNeed = add_extra_variables(tooLowData, [])

            #print tooHigh, high, nominal, low, tooLow

            # Values of the freestream properties at the perturbed conditions
            #tooHighValues = get_values(tooHighData,exitVar)
            #tooLowValues = get_values(tooLowData,exitVar)
            
            # Values of the perturbed input values
            tooHighX = dictOfCases[tooHigh][var]
            tooLowX = dictOfCases[tooLow][var]
            tooHighDeltaX = tooHighX - nominalX
            highDeltaX = highX - nominalX
            tooLowDeltaX = tooLowX - nominalX
            lowDeltaX = lowX - nominalX
            weighting = (tooHighX - tooLowX)/(highX - lowX)

            denom = 1/tooHighDeltaX - 1/tooLowDeltaX -\
                   (1/highDeltaX - 1/lowDeltaX)*weighting

            #numer =  np.array(tooHighValues)/tooHighDeltaX**2 -\
            #         np.array(tooLowValues)/tooLowDeltaX**2 -\
            #        ( np.array(highValues)/highDeltaX**2 -\
            #          np.array(lowValues)/lowDeltaX**2 )*weighting -\
            #         np.array(nominalValues)*\
            #           ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
            #             ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting )

            numer = {k: tooHighData[k]/tooHighDeltaX**2 -\
                         tooLowData[k]/tooLowDeltaX**2 -\
                       ( highData[k]/highDeltaX**2 -\
                         lowData[k]/lowDeltaX**2 )*weighting -\
                         nominalData[k]*\
                         ( 1/tooHighDeltaX**2 - 1/tooLowDeltaX**2 - \
                           ( 1/highDeltaX**2 - 1/lowDeltaX**2 )*weighting ) \
                      for k in exitVar}   
            
            #numer2values = get_values(numer2,exitVar)
            #numer2check = numer2values - numer 
            #print
            #print 'denom: ',denom
            #print
            #print 'exitVar: ',exitVar
            #print
            #print 'numer: ',numer
            #print
            #print 'numer2: ',numer2
            #print
            #print 'numer2check: ',numer2check
            #print
            #print
            
            # Calculate the absolute sensitivities
            #sensitivity_abs[var] = numer/denom
            sensitivity_abs[var] = {k: numer[k]/denom for k in exitVar}    
            
            #sens_abs2values = get_values(sensitivity_abs2[var],exitVar)
            #sens_abs2check = sens_abs2values - sensitivity_abs[var]
            
            # Calculate relative sensitivities
            #sensitivity_rel[var] = sensitivity_abs[var]*nominalX/\
            #                       np.array(nominalValues)
            sensitivity_rel[var] = {k: sensitivity_abs[var][k]*\
                                        nominalX/nominalData[k] \
                                     for k in exitVar}

            #sens_rel2values = get_values(sensitivity_rel2[var],exitVar)
            #sens_rel2check = sens_rel2values - sensitivity_rel[var]
            #
            #print 'sens_abs[var]: ',sensitivity_abs[var]
            #print
            #print 'sens_abs2[var]: ',sensitivity_abs2[var]
            #print
            #print 'sens_abs2check[var]: ',sens_abs2check
            #print
            #print 'sens_rel2check[var]: ',sens_rel2check
            #print
            
        # Now calculate the uncertainty in each exit flow variable
        # due to the uncertainty in the current (perturbed)
        # input variable
        #uncertainty[var] = sensitivity_rel[var]*inputUncertainties[var]
        
        uncertainty[var] = {k: sensitivity_rel[var][k]*\
                               inputUncertainties[var] for k in exitVar}
        
        #uncert2values = get_values(uncertainty2[var],exitVar)
        #uncert2check = uncert2values - uncertainty[var]
        #print
        #print 'exitVar: ',exitVar
        #print  
        #print 'uncertainty[var]: ',uncertainty[var]
        #print
        #print 'uncertainty2[var]: ',uncertainty2[var]
        #print
        #print 'inputUncertainties[var]: ',inputUncertainties[var]
        #print
        #print 'uncert2check: ',uncert2check
        #print
        
        
    # Write out a file of the sensitivities
    write_sensitivity_summary(sensitivity_rel, perturbedVariables,\
                              exitVar, 'relative')
    write_sensitivity_summary(sensitivity_abs, perturbedVariables,\
                              exitVar, 'absolute')
    
    # Write out a file of the uncertainties
    write_uncertainty_summary(uncertainty, perturbedVariables,\
                              exitVar, inputUncertainties)
    
    return



def main():
    """
    Examine the command-line options and then calculate the sensitivties
    and uncertainties of each property based on a set of results generated 
    by "perturb.py".
    """
    op = optparse.OptionParser(version=VERSION_STRING)
    op.add_option('-c', '--config_file', dest='config_file',
                  help=("filename for the config file"))
    opt, args = op.parse_args()
    config_file = opt.config_file
    #   
    cfg = {}
    #
    if not cfg: #if the configuration dictionary has not been filled up already, load it from a file
        try: #from Rowan's onedval program
            execfile(config_file, globals(), cfg)
        except IOError as e:
	    print "Error {0}".format(str(e)) 
            print "There was a problem reading the config file: '{0}'".format(config_file)
            print "Check that it conforms to Python syntax."
            print "Bailing out!"
            sys.exit(1)
    #
    run_sensitivity(cfg)
    #         
    return

#---------------------------------------------------------------

if __name__ == '__main__':
    if len(sys.argv) <= 1:
        print "sensitivity:\n Calculate Sensitivity of Shock Tunnel Test Flow Conditions for a varying inputs"
        print "   Version:", VERSION_STRING
        print "   To get some useful hints, invoke the program with option --help."
        sys.exit(0)
    return_flag = main()
    sys.exit(return_flag)
